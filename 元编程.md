# 元编程

元编程，顾名思义，是使用代码操控代码，达到一些常规编程难以达到的目的，比如自动处理数据库查询结果的反序列化、使用实体数据生成json等等。此部分简单介绍一些scala3的元编程手段。

## 从java谈起

这个部分跟以前不太一样，不是从kotlin开始说，而是从java开始。

我们知道，java中的元编程，通常是使用反射，并在其上发展出了动态代理等运行期元编程手段。

另外还有一些编译期元编程手段，比如注解处理器，编译器插件等等，但这种元编程手段由于使用时通常需要安装构建工具插件、ide插件等，侵入性比较高，使用体验不好。

这部分的元编程手段，kotlin与java一脉相承，并封装了更方便的反射api，以及kapt、kcp等提高编译器插件编写体验的工具，虽然便携体验相比java好了不少，但是最核心的问题没有改变，kotlin的编译期元编程的侵入性依然很高。

另外，java原本没有泛型，并且在java 1.2版本刚刚推出了一套新的集合库，所以在制作泛型功能的时候，不得不考虑兼容性，选择了类型擦除，并且保留了一种叫做`raw type`的类型标记，比如List<T>这样的类型，我们用的时候也可以直接使用List，然后就能装任何类型变量。而且，java无法实现使用泛型直接反射创建一个类型的实例，很多库里面我们不得不传入一个丑陋的T.class参数。

我们不在这里讨论类型擦除本身是好是坏，但是无疑，java上的泛型体验十分糟糕，于是kotlin中出现了一个名为`reified`的工具，通过编译器内联，我们可以使用泛型直接反射创建实例，摆脱到处传T.class的代码，而内联是实现这个功能的核心。

scala3的元编程，我们也从内联说起。

## inline

与kotlin一样，scala3也有`inline`关键字，使用`inline`可以保证函数被编译器内联。

```scala
inline def f(x: Int) = ???
```

这个函数体可以在使用时整体内联到调用点。

我们也可以使用`transparent inline`修饰方法，这种内联叫做透明内联，可以保留更具体的返回类型：

```scala
transparent inline def f: Any = 1

val x: Int = f
```

这个地方没有把Any赋值给Int的类型错误，这就是透明内联为我们保留了具体的类型信息。

并且`if`和`match`也可以添加`inline`修饰，我们知道，`if`和`match`这种分支处理，如果配合递归，就能写出强大的程序，而这些程序大多可以编译期求值，比如我们要写一个阶乘方法：

```scala
transparent inline def factorial(n: Long): Long =
   if n == 0L then 1L else n * factorial(n - 1L)

final val x = factorial(3)
```

这时候我们使用ide查看变量x的类型，会发现，它的类型不是Long，而是一个更具体的字面量类型6L，这也说明，我们写的这段程序在编译期求值并把计算后的值保留在变量里了，它没有运行期计算开销。

另外，`scala.compiletime`包中有很多强大的编译期工具。

比如我们可以这样创建一个自己的编译错误：

```scala
import scala.compiletime.error

inline def f = error("自定义编译错误")
```

那么调用这个函数的时候，应该能在ide上看到这个触发的编译错误。

再比如，由于java类型擦除，我们无法做到，传入一个泛型的集合，通过泛型的不同，触发不同的行为，因为集合的泛型在编译后就被擦掉了嘛。

kotlin由于有`reified`这种编译期处理，我们可以做这样的事情：

```kotlin
inline fun <reified T> listType(list: List<T>) {
    when (T::class.simpleName) {
        "Int" -> println("List Int")
        "String" -> println("List String")
        else -> println("List")
    }
}
```

但是如果处理的是List<List<Int>>这样的类型，kotlin就玩不转了，因为List类上面的泛型还是被擦掉了。

scala3里，可以使用`erasedValue`来处理：

```scala
import scala.compiletime.erasedValue

inline def listType[T](list: List[T]) = inline erasedValue[T] match {
    case _: Int => println("List Int")
    case _: String => println("List String")
    case _: List[Int] => println("List List Int")
    case _: List[String] => println("List List String")
    case _ => println("List")
}
```

这样，多层的泛型信息我们也可以保留下来，在编译期处理比较复杂的类型时，也能随心所欲。

上面的程序也可以稍微改造一下：

```scala
import scala.compiletime.erasedValue

inline def listType[T](list: List[T]) = inline erasedValue[T] match {
    case _: Int => println("List Int")
    case _: String => println("List String")
    case _: List[t] => inline erasedValue[t] match {
        case _: Int => println("List List Int")
        case _: String => println("List List String")
    }
    case _ => println("List")
}
```

在这个函数的第四行，模式匹配中，我们给类型参数临时起了一个“变量名”t。我们就可以在类型层面处理递归，写出更强大的“元”程序。
   
compiletime包还有很多强大的api，读者可以参考官方文档：https://docs.scala-lang.org/scala3/reference/metaprogramming/compiletime-ops.html

## 宏与编译期反射

## 类型类派生

## 实际的例子：一个json生成器
