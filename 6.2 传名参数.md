# 传名参数

有些时候，我们需要参数延迟求值，比如定义一个短路的逻辑运算，如果表达式的一部分就可以确定整个表达式的结果，那么后面的部分就没有求值的必要了。

这时候我们可以使用“传名参数”来达到延迟计算的目的，如果说普通的参数传递的是结果的值，那传名参数传递的就是表达式本身。

在Scala3里我们可以这样定义一个传名参数：

```scala
def f(x: => Int): Int = x
```

在参数类型前面添加`=>`即可定义传名参数。

我们来看一个实际的例子，我们假设Scala3没有提供内置的`while`循环，那么我们能不能自己编写一个类似的结构呢？

实际上，利用柯里化加上递归，就可以很轻易定义类似内置`while`循环的结构：

```scala
def myWhile[A](test: Boolean)(block: A): Unit =
    if test then {
        block
        myWhile(test)(block)
    }
```

我们来调用一下：

```scala
var i = 0
myWhile(i < 10) {
    println(i)
    i += 1
}
```

看起来很美好，但实际运行一下，就会发现，程序已经停不下来了，这主要是因为，第一个参数中，我们传递的是值，因为i此时为0，因此这个值永远为true，因此，程序陷入了无限递归。

我们可以利用传名参数来改造一下这个函数：

```scala
def myWhile[A](test: => Boolean)(block: => A): Unit =
    if test then {
        block
        myWhile(test)(block)
    }
```

这种改造对于调用处来说是透明的，调用的代码无需做出任何改变。

这时我们再来运行一下，就可以打印正确结果，并在运行之后正确退出了。

可以看到，利用Scala3的语法组合，我们甚至可以自己编写出其他语言必须内置的循环结构，Scala3语法的强大表达力可见一斑。