# 泛型

在Java、Scala、Kotlin这样的静态类型编程语言里，“泛型”是一个不可或缺的功能，实际上，“泛型”可以归类到多态理论中的“参数化多态”，其可以看成是一个“类型参数”。

## 定义泛型

Scala的泛型没有采用从C++模板语法开始的`<>`写法，而是采用了`[]`写法，这主要是由于，Scala的类型定义规则与函数名类似，可以采用符号写法，也就是说，这样的代码是合法的：

```scala
// scala
class <
class >
class <>

def > = ???
def < = ???
def <> = ???
```

这样的好处是有更强的内置DSL能力，也可以编写更复杂的类型计算（关于类型计算，不在这部分展开）。

而如果有这样的规则，采用`<>`就会带来很多的语法歧义，所以Scala采用了`[]`来标记泛型。

但是这又有一个问题，传统的编程语言一般使用`[]`来取数组等数据结构的下标，Scala是如何避免这个问题的呢？

答案是：Scala把数组等数据结构看成是映射，而函数的本质也是映射，所以数组等结构的下标操作，是通过函数的应用方法`apply`来完成的，而我们知道，`apply()`通常可以直接简写成`()`，所以在Scala里，下标操作写法如下：

```scala
// scala
val arr = Array(1, 2)
val v0 = arr.apply(0)
val v1 = arr(1)
```

这也是Scala的设计思想之一，不把数组等标准库提供的数据结构看作可以凌驾于其它对象之上的存在，只把他们当做普通对象，因此，标准库提供的数据结构的用法，第三方库的数据结构同样可以提供。

话题回到泛型，我们可以在类，特质等结构上标记泛型：

```scala
// scala
trait A[T]

class B[T] extends A[T]
```

如果说泛型标记是“形参”的话，那么创建泛型类的实例就需要提供“实参”：

```scala
// scala
val b = new B[String]
```

如果我们不能确定泛型的实际类型，可以采用“泛型通配符”，可以使用`?`或者`_`（Scala3推荐的写法是`?`）:

```scala
// scala
val list: List[A[?]] = List()
```

这样的List就可以存入有着不同类型参数的A的实例。这种“泛型通配符”对应着类型理论中的“存在类型”，此处不展开，感兴趣的读者可以自行阅读类型理论相关的著作。

除了类、特质等可以有类型参数，方法也可以有类型参数：

```scala
// scala
def f[T]: T = ???
```

我们可以这样来调用：

```scala
// scala
val v = f[Int]
```

如果类型参数不填，则默认为`Nothing`：

```scala
// scala
val v = f // Nothing
```

如果类型参数能被编译器自动推断出来，那么也可以省略不写：

```scala
// scala
case class A[T](x: T)
val a = A(1) // A[Int]

def f[T](x: T): T = x
val v = f("x") // String
```

泛型为我们提供了更高的抽象能力，可以在更高的维度上编写代码。

除了简单的泛型之外，Scala3还提供了Java、Kotlin不支持的“高阶泛型”、“类型模式匹配”等功能，在类型层面上的编程能力，Java和Kotlin无法与Scala3相提并论。