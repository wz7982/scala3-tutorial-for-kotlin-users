# 匹配类型

在之前的部分里，一直在重复一个观念，类型定义可以看作是类型层面的函数，而泛型可以看作是类型函数的参数，但是之前，我们只知道如何类型做一些基本的变换，下面就来介绍如何编写更复杂的类型函数。

不知道看到这里之前，你有没有尝试`match`这个Scala3提供的强大的控制结构，并熟练运用它。如果你还没有熟悉`match`，那么最好先熟悉它，再来看本节的内容。

`match`这个控制结构足够强大，其可以表达分支，也可以用来处理递归，而如果有了分支和递归，理论上就可以写出来任何程序。Scala3支持我们在类型层面进行`match`，用于编写类型层面的函数。

先来看一个简单的例子：

```scala
type F[X <: Boolean] = X match {
    case true => Int
    case false => String
}
```

我们先创建了一个类型函数F，要求其类型参数X必须是Boolean的子类型，而我们在单例类型部分介绍过，Boolean有两个单例子类型true和false，可以利用这一点，对类型参数X进行匹配，如果是true，则返回Int类型，如果是false，则返回String类型。

然后，我们就可以在普通的函数上应用这种类型：

```scala
def f(x: Boolean, y: F[x.type]) = y
```

来测试一下：

```scala
// 编译通过
f(true, 1)
f(false, "x")

// 编译错误
f(true, "x")
f(false, 1)
```

这样，我们就创建了一个奇特的函数，其第二个参数的类型，依赖于第一个参数的值，这样的函数可以叫做“依赖类型”函数。

类型函数也可以用在返回类型上面：

```scala
def f(x: Boolean): F[x.type] = x match {
    case _: true => 1
    case _: false => "x"
}
```

来测试一下：

```scala
val v1 = f(true) // Int

val v2 = f(false) // String
```

函数返回类型根据参数的值变化，看起来有点类似动态类型语言，但是，这个类型仍然在编译期确定，依然是动态类型，比如下面的代码会产生编译错误：

```scala
var v = f(true)
v = "a" // 编译错误，把String类型的值赋给了Int类型的变量
```

利用这样的类型函数，我们可以做更加安全的编译期检查。

来看一个更复杂的例子，之前提到过，元组的`apply`方法，是可以在编译期检查下标是否越界的，那么，标准库是如何完成这样的检查的？

先把目标定的低一些，编写一个类型函数，接收一个元组类型，并返回元组的长度：

```scala
import scala.compiletime.ops.int.+

type Length[T <: Tuple] <: Int = T match {
    case _ *: t => Length[t] + 1
    case EmptyTuple => 0
}
```

这个Length函数是递归的，我们用模式匹配解构元组，如果是非空元组，则返回其尾元组的长度加1，反复匹配直到匹配到一个空元组，这时返回0。

> 元组本身是递归构造的，如果你还不熟悉这种构造方式，请回看标准库部分。

我们来测试一下：

```scala
val tup = (1, "x")
val length: Length[tup.type] = 2
```

这个例子是可以编译通过的，但是如果改为下面这样，就会产生编译错误：

```scala
val tup = (1, "x")
val length: Length[tup.type] = 3 // 编译错误
```

可以看到，使用类型层面的模式匹配，我们可以编写出更加详尽的类型检查，让程序变得更安全，这完全超越了Java、Kotlin这样传统的静态类型系统。

> scala.compile.ops包里，内置了一些基本的类型函数，我们可以使用这些函数编写出更复杂的函数。